package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;
    private HeapFileIterator outerHeapFileIterator;
    private HeapFileIterator innerHeapFileIterator;

    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;
    private Tuple _lastMatch = null; //for SMJ: store the first match tuple in innerRelation 

	private List<Tuple> mInnerList = new ArrayList<Tuple>();

	private int mIndex;
    
    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;
      
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
	//IMPLEMENT THIS
    	this._predicate = p;
    	this._outerRelation = child1;
    	this._innerRelation = child2;
    }

    public void setJoinAlgorithm(int joinAlgo){
	_joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
	//IMPLEMENT THIS
    	return TupleDesc.combine(_outerRelation.getTupleDesc(), _innerRelation.getTupleDesc());
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
	//IMPLEMENT THIS
    	_outerRelation.open();
    	_innerRelation.open();
    	//PNL
		outerHeapFileIterator = ((HeapFileIterator)((SeqScan)_outerRelation).getIterator());
		innerHeapFileIterator = ((HeapFileIterator)((SeqScan)_innerRelation).getIterator());
		mIndex = 0;
    }

    private void addToInnerList() {
		try {
			while (innerHeapFileIterator.hasNext()) {
				_innerRecent = innerHeapFileIterator.next();
				mInnerList.add(_innerRecent);			}
		} catch (DbException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransactionAbortedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
    
    public void close() {
    //IMPLEMENT THIS
    	_outerRelation.close();
    	_innerRelation.close();
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
    //IMPLEMENT THIS
    	_innerRelation.rewind();
    	_outerRelation.rewind();
    }
    
    //for SMJ: if t1 > t2 , return true;
    private boolean tupleCompare(Tuple t1, Tuple t2){
		return _predicate.getLeftField(t1).compare(Predicate.Op.GREATER_THAN, _predicate.getRightField(t2));   	
    }
    
    private Tuple backToLastMatch(Tuple currentTuple, Tuple lastMatch, HeapFileIterator relation){
    	while(!currentTuple.equals(lastMatch)){
    		try {
    			currentTuple = relation.previous();
			} catch (NoSuchElementException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TransactionAbortedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (DbException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
    	try {
			currentTuple = relation.next();
		} catch (DbException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransactionAbortedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	return currentTuple;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
	switch(_joinType){
	case SNL: return SNL_readNext();
	case PNL: return PNL_readNext();
	case BNL: return BNL_readNext();
	case SMJ: return SMJ_readNext();
	case HJ: return HJ_readNext();
	default: return SNL_readNext();
	}
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
    	//IMPLEMENT THIS 
    	try {
			if(!_outerRelation.hasNext() && !_innerRelation.hasNext()){
				return null;
			}
			if(_outerRecent == null){
				_outerRecent = _outerRelation.next();
			}
			while(_outerRelation.hasNext() || _outerRecent != null){
				while(_innerRelation.hasNext()){
					_innerRecent = _innerRelation.next();
					_numComp++;
					if(_predicate.filter(_outerRecent, _innerRecent)){
						_numMatches++;
						return joinTuple(_outerRecent, _innerRecent, getTupleDesc());
					}
				}
				if(!_outerRelation.hasNext()){
					return null;
				}
				else{
					_outerRecent = _outerRelation.next();
					_innerRelation.rewind();
				}				
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	return null;
    }

    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
	//IMPLEMENT THIS (EXTRA CREDIT ONLY)
		try {
			addToInnerList(); //load innerPages
			while (true) {
				if (_outerRecent == null) {
					_outerPage = outerHeapFileIterator.getCurrentPage().iterator();
					_outerRecent = _outerPage.next();
					outerHeapFileIterator.next();
				}
				if (mIndex < mInnerList.size()) { //if innerPage have next tuple
					_innerRecent = mInnerList.get(mIndex);
					if (_predicate.filter(_outerRecent, _innerRecent)) {
						_numMatches++;
						mIndex++;
						return joinTuple(_outerRecent, _innerRecent, getTupleDesc());
					}
					mIndex++;
				} else { //run to the end of innerRelation, read next outerTuple
					mIndex = 0;
					if (_outerPage.hasNext()) { 
						_outerRecent = _outerPage.next();
						outerHeapFileIterator.next();
					} else { // no outerTuple
						if (outerHeapFileIterator.hasNext()) { //read next outerPage
							//load innerPages
							innerHeapFileIterator.rewind();
							mInnerList.clear();
							addToInnerList();
							_outerPage = outerHeapFileIterator.getCurrentPage().iterator();
							_outerRecent = _outerPage.next();
							outerHeapFileIterator.next();
						} else { // no next outerPage -> the join algorithm is done
							break;
						}
					}

				}
            }
		} catch (IOException e) {
			e.printStackTrace();
		}
		mIndex++;
		return null;
    }

    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }

    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
		try {
			if (!outerHeapFileIterator.hasNext() && !innerHeapFileIterator.hasNext()) {
				return null;
			}
			if (_outerRecent == null && outerHeapFileIterator.hasNext())
                _outerRecent = outerHeapFileIterator.next();
			if (_innerRecent == null && innerHeapFileIterator.hasNext())
				_innerRecent = innerHeapFileIterator.next();
		} catch (IOException e) {
			e.printStackTrace();
		}

		Tuple result = null;
		Tuple outerNext;

		try {
			while (outerHeapFileIterator.hasNext() || innerHeapFileIterator.hasNext()) {
				if (tupleCompare(_innerRecent, _outerRecent)) { //_inner > _outer
					if (outerHeapFileIterator.hasNext()) {
						outerNext = outerHeapFileIterator.next();
						if (!tupleCompare(outerNext, _outerRecent)) {
							// outer next is not bigger than current one => equal
							// inner need to reverse
							_innerRecent = backToLastMatch(_innerRecent, _lastMatch, innerHeapFileIterator);
							continue;
						}
						_outerRecent = outerNext;
					} else {
						_lastMatch = null;
						break;
					}
				} else if (tupleCompare(_outerRecent, _innerRecent)) { // _outer > _inner
					if (innerHeapFileIterator.hasNext()) {
						_innerRecent = innerHeapFileIterator.next();
					} else {
						break;
					}

				} else {
					// equal case
					if(_lastMatch == null){
						_lastMatch = _innerRecent;
					}					
					result = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
					_numMatches++;
					if (innerHeapFileIterator.hasNext()) {
						_innerRecent = innerHeapFileIterator.next();
					} else {
						if (outerHeapFileIterator.hasNext()) {
							_outerRecent = outerHeapFileIterator.next();
							_innerRecent = backToLastMatch(_innerRecent, _lastMatch, innerHeapFileIterator);
						}
					}
					break;
				}
            }
		} catch (IOException e) {
			e.printStackTrace();
		}

		try { //compare last one
			if (!outerHeapFileIterator.hasNext() && !innerHeapFileIterator.hasNext()) {
				if (!tupleCompare(_outerRecent, _innerRecent) && !tupleCompare(_innerRecent, _outerRecent)) {
					result = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
					_numMatches++;
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		return result;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
	//IMPLEMENT THIS
    	Tuple joinTuple = new Tuple(tupledesc);
    	for(int i = 0; i < tupledesc.numFields(); i++){
    		if( i >= outer.getTupleDesc().numFields()){
    			joinTuple.setField(i, inner.getField(i - outer.getTupleDesc().numFields()));
    		}
    		else{
    			joinTuple.setField(i, outer.getField(i));
    		}
    	}
    	return joinTuple;
	//return null;
    }

    public int getNumMatches(){
	return _numMatches;
    }
    public int getNumComp(){
	return _numComp;
    }
}
